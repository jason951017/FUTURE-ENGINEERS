# 機器人比賽工程日誌 - 視覺感應避障電動車

## 簡介

歡迎來到我們的機器人比賽工程日誌！我們準備參加一場視覺感應避障電動車的比賽。我們的目標是製作一台自動導航並能根據視覺感應器來避免障礙物的電動車。這份日誌將記錄我們在組裝和優化車輛過程中的進展、挑戰和解決方案。
# 壹.移動性管理

## 一. 馬達選擇

在初期階段，我們仔細考慮了不同的馬達選項，最終選擇了更小的N20馬達，而不是EV3樂高馬達。這個選擇不僅讓我們的車輛更加緊湊，還能提供更好的靈活性，以實現有效的閃避障礙物。

![N20馬達](1.移動性管理/n20馬達.jpeg)
![EV3馬達](1.移動性管理/EV3馬達.jpg)

## 二. 底盤設計

為了確保車輛的機動性，我們決定使用3D列印技術設計一個自定義的底盤，同時解決了遙控車底盤迴轉半徑過大的問題。這個決定將讓我們製作一個專為我們需求度身訂造的底盤，以提高整體性能。

### 遙控車迴轉半徑：

![遙控車](1.移動性管理/搖1.jpg)
![遙控車](1.移動性管理/搖2.jpg)

### 3D列印車迴轉半徑：

![3D車](1.移動性管理/自1.jpg)
![3D車](1.移動性管理/自2.jpg)

由上圖比對發現遙控車底盤迴轉半徑過大，可能影響閃避交通號誌，所以最終選擇用3D列印底盤車解決此問題。

## 三. 3D列印齒輪

為了確保馬達和樂高零件的齒輪相匹配，我們自行使用3D列印技術設計了合適的齒輪。這將實現在車輛內部有效地傳遞動力。

![自製齒輪](1.移動性管理/齒輪.jpg)

## 四. 馬達轉速

我們進行了馬達轉速的測試，以瞭解其性能特點。以下是馬達在不同電壓下的轉速結果圖：

紅色框選部分為我們挑選馬達的數據

![馬達轉速圖](1.移動性管理/馬達轉速.png)

## 五. 差速器齒輪比

為了實現差速操控，我們計算並設計了適合後輪的差速器齒輪比大約等於400*(16-24)=266.667

![差速器齒輪](1.移動性管理/差速器.jpg)

## 六. 裝配說明

以下是包括底盤和框架的裝配指南和零件實裝圖：

![裝配說明](1.移動性管理/底盤解說圖.png)
![](1.移動性管理/底盤裝配圖.jpg)

## 七. 3D元件三視圖及stl圖檔

整個車輛元件的三視圖：

### 頂視圖：

![頂視圖](1.移動性管理/視圖.png)

### 正視圖：

![正視圖](1.移動性管理/上視圖.png)

### 側視圖：

![側視圖](1.移動性管理/側視圖.png)

### stl圖檔：

[stl圖檔](1.移動性管理/FE全.stl)

# 貳.電源和感測器管理

## 一. nicjoy14500金屬鋰電池

這是車輛的動力來源，提供電力給主控板、馬達以及其他電子裝置。選用金屬鋰電池而不是模型電池是因為nicjoy金屬鋰電池體積更小，更方便縮小車輛體積及配重。
一節電池電壓為3.7 ~ 4.2伏特，穩態電壓3.7伏特，我們使用兩節電池實際電壓為7.4 ~ 8.4伏特，電壓輸入到主控版後會經過穩壓晶片將電壓穩壓到5伏特和3.3伏特再分配到主控板和其他感應器。

![image](2.電源和感測器管理/電池.jpeg)

## 二.主控板

Krduino主控板：這是整個車輛的主要控制板，負責管理和協調其他零件的運作。主控板通過程式碼控制各個感測器和執行器的動作，實現車輛的自主運行和障礙物避免功能。

![image](2.電源和感測器管理/Krduino.jpg)

  #### 二-1 馬達驅動馬達驅動版tb6612

   tb6612是用於控制電動車的馬達。在車輛中，tb6612驅動晶片負責控制馬達的速度和方向，進而實現車輛的運動和轉向控制。已內建整合於主控板中。

   ![image](2.電源和感測器管理/ttb6612.jpg)

## 三.陀螺儀mpu6050

這是一個慣性感測器，能夠檢測車輛的傾斜和轉動。通過i2c通訊讀取陀螺儀數據，主控板可以判斷車輛的傾斜狀態，從而實現平穩的移動和轉向。

![image](2.電源和感測器管理/mpu6050.jpg)

## 四.顏色感應器tcs34725

這個感應器可以識別周圍環境的顏色。在比賽中，我們通過i2c通訊讀取感應器數據來辨別地面狀態，以便車輛做出適當的反應和閃避動作。

![image](2.電源和感測器管理/TCS34725.jpg)

## 五.攝影機esp32cam

攝影機是視覺感應器的一種，它可以拍攝周圍的場景。透過攝影機的影像處理，車輛可以識別前方的障礙物或路徑，並進行適應性的運動控制。

![image](2.電源和感測器管理/esp32cam.jpg)

## 六.超音波hc-sr04

這個超音波感測器可以測量車輛與前方障礙物之間的距離。藉由這個數據，車輛可以避免與障礙物碰撞，實現安全的運行。

![image](2.電源和感測器管理/hc-sr04.jpg)

## 七.按鈕

按鈕是一種輸入裝置，可以用來控制車輛的啟動、停止或其他功能。在比賽中，我們將按鈕用來操控車輛的啟動。

![image](2.電源和感測器管理/按鈕.jpg)

## 八.三色指示燈

這些燈光裝置用來顯示車輛的狀態或提供提示信息。例如，可以利用指示燈顯示車輛是否處於運行中，或者是否偵測到了障礙物，若程式有誤還能方便及時更正程式。

![image](2.電源和感測器管理/燈.jpg)

# 參.障礙管理

以下是我們車輛的程式碼

```
#include "init.h"

int ya = 0, yb = 1, cmin, cmax;

void setup() {
  // 初始化感應器
  FeInit();
  getDis();
  delayMicroseconds(250);
  static int ldis, fix5 = 0, lastColor = 0, turnback = 0;
  while (true) {
    // 沿陀螺儀相對零度角前進並進行避障
    rygSet(0, 0, 0);
    if ((CameraGet(3) > 15) || (CameraGet(7) > 15)) {
      caturn_turn();
      if (CameraGet(3) > 15) fix5 = -20;
      if (CameraGet(7) > 15) fix5 = 20;
    } else {
      setTurn(getRelGyro(0) * 1.2);
    }
    motorSpd(250);
    // 利用光源感應器分辨地面上藍橘線得知行進方向為順時針或逆時針
    int color = getTcs();
    if (color > 0 && color < 40) {
      ya = 1;
      cmin = 0;
      cmax = 40;
      break;
    }
    if (color > 200 && color < 240) {
      ya = -1;
      cmin = 200;
      cmax = 240;
      break;
    }
  }
}

// 20,220
void loop() {
  rygSet(0, 0, 0);
  static byte b = 0, c = 0;
  static int ldis, fix5 = 0, lastColor = 0;
  static uint32_t a = 0, timer = 0, back = 0, straightTime = 0;
  motorSpd(250);
  // 記數進行8次
  for (int r = 0; r < 8; r++) {
    // 前進直到偵測到地圖上藍橘線
    while (getTcs() < cmin || getTcs() > cmax) {
      // 沿陀螺儀相對零度角前進並進行避障
      if ((CameraGet(3) > 15) || (CameraGet(7) > 15)) {
        caturn_turn();
      } else {
        setTurn(getRelGyro(a + fix5) * 1.2);
      }
      if (r == 4) {
        if (CameraGet(3) > 15) {
          // 將相對角目標調整90度
          a += ya * 90;
        }
        //*****************************************************************************
        // 轉向直到與目標角度相差小於10度
        while (getRelGyro(a) > 10 || getRelGyro(a) < -10) {
          motorSpd(250);
          // 在觀測到障礙後進行避障
          if ((CameraGet(3) > 15) || (CameraGet(7) > 15)) {
            caturn_turn();
          }
          setTurn(getRelGyro(a) * 1.2);
        }
      }
    }
  }
  //*********************************************************************************************
  straightTime = millis() + 700;
  if (lastColor == -1) {
    rygSet(0, 0, 0);
    // 前進0.7秒並在途中進行避障
    while (millis() < straightTime) {
      motorSpd(250);
      caturn_turn();
    }
    //*************************************************************************************************
    // 改變地面上藍橘線目標色相值
    if (ya == 1) {
      cmin = 200;
      cmax = 240;
    } else {
      cmin = 0;
      cmax = 40;
    }
    // 沿相對角180度後退
    straightTime = millis() + 1800;
    while (millis() < straightTime) {
      motorSpd(-250);
      setTurn(getRelGyro(a) * (-1));
    }
    // 轉向直到與目標角相差小於10度
    a += ya * 90;
    while (getRelGyro(a) > 10 || getRelGyro(a) < -10) {
      motorSpd(250);
      setTurn(getRelGyro(a) * 1.2);
    }
  }
  //****************************************************************************
  // 前進1秒並在途中進行避障
  straightTime = millis() + 1000;
  while (millis() < straightTime) {
    setTurn(getRelGyro(a) * 1.2);
    caturn_turn();
  }
  //****************************************************************************
  // 記數3+(是否往反方向)次
  for (int r = 0; r < (3 + (lastColor > 0)); r++) {
    // 前進直到偵測到地圖上藍橘線
    while (getTcs() < cmin || getTcs() > cmax) {
      // 沿陀螺儀相對零度角前進並進行避障
      if ((CameraGet(3) > 15) || (CameraGet(7) > 15)) {
        caturn_turn();
      } else {
        setTurn(getRelGyro(a + fix5) * 1.2);
      }
    }
    //******************************************************************************************
    // 將目標角調整90度
    a += ya * 90 * lastColor;
    //******************************************************************************************
    // 轉向直到與目標角度相差小於10度
    while (getRelGyro(a) > 10 || getRelGyro(a) < -10) {
      motorSpd(250);
      // 在觀測到障礙後進行避障
      if ((CameraGet(3) > 15) || (CameraGet(7) > 15)) {
        caturn_turn();
      }
      setTurn(getRelGyro(a) * 1.2);
    }
  }
  //*******************************************************************************************
  // 前進0.8秒後停止
  straightTime = millis() + 800;
  while (millis() < straightTime) {
    motorSpd(250);
    caturn_turn();
  }
  while (1) {
    motorSpd(0);
  }
}

```

# 肆.圖片-團隊以及汽車

## 一.團隊照片

![隊伍照片](4.圖片-團隊以及汽車/隊伍照片1.jpg)
![隊伍照片](4.圖片-團隊以及汽車/隊伍照片2.jpg)

## 二.車輛照片

![image](4.圖片-團隊以及汽車/車1.jpg)

## 側視圖:

![image](4.圖片-團隊以及汽車/側視車2.jpg)

## 上視圖:

![image](4.圖片-團隊以及汽車/上視車1.jpg)

# 伍.完整的影片

## 影片連結:

### future engineer-開放挑戰
https://www.youtube.com/watch?v=iF_I76seYgM

### 障礙物挑戰-有迴轉
https://www.youtube.com/watch?v=U3aca9URPHw

### 障礙物挑戰-無迴轉
https://www.youtube.com/watch?v=v_WyIpfcISQ

# 陸.GitHub使用

## GitHub使用心得
我是一個幾乎不會打報告、上網查資料的人，但這次參加Future Engineer比賽之後，我開始使用GitHub來紀錄我的比賽實驗過程。這是一個讓我難以置信的改變，讓我在技術和協作方面得到了巨大的成長。一開始，我對於GitHub毫無了解，但是在比賽中，我不得不學會如何使用它，因為它是我們整個比賽的過程記錄中心。這次Future Engineer比賽讓我成為了一個會使用GitHub、上網查資料的人。GitHub幫助我更好地組織我的工作、與團隊合作、學習他人的經驗，並且使我對於技術更加自信。我相信這個工具將會伴隨著我在未來的學習和職業生涯中，繼續扮演著重要的角色。

# 柒.工程因素及技術條件
這一個章節要呈現我們自行設計和製造車輛和部件，以及整合現成的電子零件。

## 一.現成電子零件

### 1.nicjoy14500金屬鋰電池

這是車輛的動力來源，提供電力給主控板、馬達以及其他電子裝置。選用金屬鋰電池而不是模型電池是因為nicjoy金屬鋰電池體積更小，更方便縮小車輛體積及配重。
一節電池電壓為3.7 ~ 4.2伏特，穩態電壓3.7伏特，我們使用兩節電池實際電壓為7.4 ~ 8.4伏特，電壓輸入到主控版後會經過穩壓晶片將電壓穩壓到5伏特和3.3伏特再分配到主控板和其他感應器。

![image](7.工程因素及技術條件/電池.jpeg)

### 2.主控板

Krduino主控板：這是整個車輛的主要控制板，負責管理和協調其他零件的運作。主控板通過程式碼控制各個感測器和執行器的動作，實現車輛的自主運行和障礙物避免功能。

![image](7.工程因素及技術條件/Krduino.jpg)

   2-1 馬達驅動馬達驅動版tb6612

   tb6612是用於控制電動車的馬達。在車輛中，tb6612驅動晶片負責控制馬達的速度和方向，進而實現車輛的運動和轉向控制。已內建整合於主控板中。

   ![image](7.工程因素及技術條件/ttb6612.jpg)

### 2.陀螺儀mpu6050

這是一個慣性感測器，能夠檢測車輛的傾斜和轉動。通過i2c通訊讀取陀螺儀數據，主控板可以判斷車輛的傾斜狀態，從而實現平穩的移動和轉向。

![image](7.工程因素及技術條件/mpu6050.jpg)

### 3.顏色感應器tcs34725

這個感應器可以識別周圍環境的顏色。在比賽中，我們通過i2c通訊讀取感應器數據來辨別地面狀態，以便車輛做出適當的反應和閃避動作。

![image](7.工程因素及技術條件/TCS34725.jpg)

### 4.攝影機esp32cam

攝影機是視覺感應器的一種，它可以拍攝周圍的場景。透過攝影機的影像處理，車輛可以識別前方的障礙物或路徑，並進行適應性的運動控制。

![image](7.工程因素及技術條件/esp32cam.jpg)

### 5.超音波hc-sr04

這個超音波感測器可以測量車輛與前方障礙物之間的距離。藉由這個數據，車輛可以避免與障礙物碰撞，實現安全的運行。

![image](7.工程因素及技術條件/hc-sr04.jpg)

### 6.按鈕

按鈕是一種輸入裝置，可以用來控制車輛的啟動、停止或其他功能。在比賽中，我們將按鈕用來操控車輛的啟動。

![image](7.工程因素及技術條件/按鈕.jpg)

### 7.三色指示燈

這些燈光裝置用來顯示車輛的狀態或提供提示信息。例如，可以利用指示燈顯示車輛是否處於運行中，或者是否偵測到了障礙物，若程式有誤還能方便及時更正程式。

![image](7.工程因素及技術條件/燈.jpg)

## 二. 介紹初代汽車和改進後的車輛

### 1.初代汽車照片
![舊車](7.工程因素及技術條件/舊車.jpg)
![舊車](7.工程因素及技術條件/舊車1.jpg)
![EV3馬達](7.工程因素及技術條件/EV3馬達.jpg)

這是改裝前的初代汽車底盤照片，使用的是EV3馬達，整輛車幾乎都是用樂高零件組成，看起來是一輛體積相對稍大的車輛。

### 2.改進後的車輛
![image](7.工程因素及技術條件/車1.jpg)

這是改進後的車輛照片，我們改裝了底盤和馬達，加入了新的零件和設備，使車輛體積縮小的同時擁有了更多功能。

## 三. 焊接電路板和電路板功能
我們加裝這塊電路板是因為之前沒電路板的機構容易因使用時常增加，導致杜邦線鬆，動進而引發接觸不良的問題，所以自己到電子材料行買了兩塊焊接板自己製作一塊電路板。

### 1.電路板接線設計圖
![電路板接線設計圖](7.工程因素及技術條件/pIYBAF8PvcGAd8HXAAAZEUwlF1s603.png)

這是我們為電路板進行的接線設計圖，確保電路板的連接正確，以實現各個零件間的順利通訊。

### 2.電路板焊接過程
![電路板](7.工程因素及技術條件/電路板11.jpg)
![電路板](7.工程因素及技術條件/電路板22.jpg)
![電路板](7.工程因素及技術條件/電路板33.jpg)

這是電路板焊接過程的照片，我們仔細地將各個電子元件焊接在電路板上，確保連接可靠且無誤。

### 3.電路板完成圖
![電路板完成圖](7.工程因素及技術條件/電路板完成圖11.jpg)
![電路板完成圖](7.工程因素及技術條件/電路板完成圖22.jpg)

### 4.電路板突發狀況

由於鄰近比賽，車輛上的krduino主控板晶片因操作不當導致短路燒壞控板，所以主控板臨時改成arduino UNO板。

由於krduino板和UNO板有一些腳位差異，所以將電路板的一些接角重新焊接。
![出事](7.工程因素及技術條件/出事.jpg)


這是已完成且裝配好的電路板照片，所有電子元件都已經焊接完成並接線正確。這個電路板是整個車輛的核心，它負責接收和處理各個感測器的數據，並控制馬達和其他執行器的動作，以實現車輛的自主運行和視覺感應閃避障礙物功能。
## 四. 底盤設計

為了確保車輛的機動性，我們決定使用3D列印技術設計一個自定義的底盤，同時解決了遙控車底盤迴轉半徑過大的問題。這個決定將讓我們製作一個專為我們需求度身訂造的底盤，以提高整體性能。

### 1. 遙控車迴轉半徑：

![遙控車](7.工程因素及技術條件/搖1.jpg)
![遙控車](7.工程因素及技術條件/搖2.jpg)

### 3D列印車迴轉半徑：

![3D車](7.工程因素及技術條件/自1.jpg)
![3D車](7.工程因素及技術條件/自2.jpg)

由上圖比對發現遙控車底盤迴轉半徑過大，可能影響閃避交通號誌，所以最終選擇用3D列印底盤車解決此問題。
